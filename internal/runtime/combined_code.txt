This file contains the combined code from multiple files in a folder.
The purpose is to provide the LLM with a single, consolidated file for analysis and understanding of the entire codebase.

============================

// File: ./memory.go
package runtime

import (
	"fmt"
	"sync"

	"github.com/tetratelabs/wazero/api"
)

// MemoryAllocator is no longer actively used if we rely solely on the contract's allocator.
type MemoryAllocator struct {
	mu          sync.Mutex
	heapStart   uint32
	current     uint32
	allocations map[uint32]uint32
	freeList    []memoryRegion
}

type memoryRegion struct {
	offset uint32
	size   uint32
}

func NewMemoryAllocator(heapStart uint32) *MemoryAllocator {
	return &MemoryAllocator{
		heapStart:   heapStart,
		current:     heapStart,
		allocations: make(map[uint32]uint32),
		freeList:    make([]memoryRegion, 0),
	}
}

// We no longer call this from host code if we rely on contract's allocate.
// Leaving it here if needed for testing or fallback.
func (m *MemoryAllocator) Allocate(mem api.Memory, size uint32) (uint32, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// ... omitted for brevity ...
	return 0, fmt.Errorf("Allocate should not be used at runtime if contract has 'allocate'")
}

// We also do not call this from the host.
func (m *MemoryAllocator) Free(offset uint32) error {
	// ...
	return nil
}

// ----------------------------------------------------------------------
// COMMENTED OUT: RegisterMemoryManagement
// This is no longer used because the contractâ€™s allocate / deallocate exports are used instead.
//
// func RegisterMemoryManagement(builder wazero.HostModuleBuilder, allocator *MemoryAllocator) {
// 	builder.NewFunctionBuilder().
// 		WithFunc(func(_ context.Context, mod api.Module, size uint32) uint32 {
// 			offset, err := allocator.Allocate(mod.Memory(), size)
// 			if err != nil {
// 				panic(err)
// 			}
// 			return offset
// 		}).
// 		Export("allocate")
//
// 	builder.NewFunctionBuilder().
// 		WithFunc(func(_ context.Context, _ api.Module, offset uint32) {
// 			if err := allocator.Free(offset); err != nil {
// 				panic(err)
// 			}
// 		}).
// 		Export("deallocate")
// }
// ----------------------------------------------------------------------

// WriteMemory and ReadMemory remain useful helpers unrelated to the custom allocator.

func WriteMemory(mem api.Memory, offset uint32, data []byte) error {
	if !mem.Write(offset, data) {
		return fmt.Errorf("failed to write %d bytes at offset %d", len(data), offset)
	}
	return nil
}

func ReadMemory(mem api.Memory, offset, length uint32) ([]byte, error) {
	data, ok := mem.Read(offset, length)
	if !ok {
		return nil, fmt.Errorf("failed to read %d bytes at offset %d", length, offset)
	}
	return data, nil
}

// Additional helper code unchanged ...

============================

// File: ./wasmruntime.go
// file: internal/runtime/wasm_runtime.go
package runtime

import "github.com/CosmWasm/wasmvm/v2/types"

type WasmRuntime interface {
	// InitCache sets up any runtime-specific cache or resources. Returns a handle.
	InitCache(config types.VMConfig) (any, error)

	// ReleaseCache frees resources created by InitCache.
	ReleaseCache(handle any)

	// Compilation and code storage
	StoreCode(code []byte, persist bool) (checksum []byte, err error)
	StoreCodeUnchecked(code []byte) ([]byte, error)
	GetCode(checksum []byte) ([]byte, error)
	RemoveCode(checksum []byte) error
	Pin(checksum []byte) error
	Unpin(checksum []byte) error
	AnalyzeCode(checksum []byte) (*types.AnalysisReport, error)

	// Execution lifecycles
	Instantiate(checksum []byte, env []byte, info []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	Execute(checksum []byte, env []byte, info []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	Migrate(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	MigrateWithInfo(checksum []byte, env []byte, msg []byte, migrateInfo []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	Sudo(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	Reply(checksum []byte, env []byte, reply []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	Query(checksum []byte, env []byte, query []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)

	// IBC entry points
	IBCChannelOpen(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCChannelConnect(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCChannelClose(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCPacketReceive(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCPacketAck(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCPacketTimeout(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCSourceCallback(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)
	IBCDestinationCallback(checksum []byte, env []byte, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error)

	// Metrics
	GetMetrics() (*types.Metrics, error)
	GetPinnedMetrics() (*types.PinnedMetrics, error)
}

============================

// File: ./wazeroruntime.go
package runtime

import (
	"context"
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"strings"
	"sync"

	"github.com/CosmWasm/wasmvm/v2/types"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
)

type WazeroRuntime struct {
	mu              sync.Mutex
	runtime         wazero.Runtime
	codeCache       map[string][]byte
	compiledModules map[string]wazero.CompiledModule
	closed          bool

	// Pinned modules tracking
	pinnedModules map[string]struct{}
	moduleHits    map[string]uint32
	moduleSizes   map[string]uint64

	// Contract execution environment
	kvStore types.KVStore
	api     *types.GoAPI
	querier types.Querier
}

type RuntimeEnvironment struct {
	DB      types.KVStore
	API     types.GoAPI
	Querier types.Querier
	Memory  *MemoryAllocator
	Gas     types.GasMeter
	GasUsed types.Gas

	// Iterator management
	iteratorsMutex sync.RWMutex
	iterators      map[uint64]map[uint64]types.Iterator
	nextIterID     uint64
	nextCallID     uint64
}

func NewWazeroRuntime() (*WazeroRuntime, error) {
	// Create a wazero config with increased memory.
	// For example, allow up to 128 pages (8 MiB) instead of the default 1 page.
	config := wazero.NewRuntimeConfigInterpreter().
		WithMemoryLimitPages(2048)

	// Create the wazero runtime using the custom config.
	r := wazero.NewRuntimeWithConfig(context.Background(), config)

	// Create mock implementations
	kvStore := &MockKVStore{}
	api := NewMockGoAPI()
	querier := &MockQuerier{}

	return &WazeroRuntime{
		runtime:         r,
		codeCache:       make(map[string][]byte),
		compiledModules: make(map[string]wazero.CompiledModule),
		closed:          false,
		pinnedModules:   make(map[string]struct{}),
		moduleHits:      make(map[string]uint32),
		moduleSizes:     make(map[string]uint64),
		kvStore:         kvStore,
		api:             api,
		querier:         querier,
	}, nil
}

// Mock implementations for testing
type MockKVStore struct{}

func (m *MockKVStore) Get(key []byte) []byte                            { return nil }
func (m *MockKVStore) Set(key, value []byte)                            {}
func (m *MockKVStore) Delete(key []byte)                                {}
func (m *MockKVStore) Iterator(start, end []byte) types.Iterator        { return &MockIterator{} }
func (m *MockKVStore) ReverseIterator(start, end []byte) types.Iterator { return &MockIterator{} }

type MockIterator struct{}

func (m *MockIterator) Domain() (start []byte, end []byte) { return nil, nil }
func (m *MockIterator) Next()                              {}
func (m *MockIterator) Key() []byte                        { return nil }
func (m *MockIterator) Value() []byte                      { return nil }
func (m *MockIterator) Valid() bool                        { return false }
func (m *MockIterator) Close() error                       { return nil }
func (m *MockIterator) Error() error                       { return nil }

func NewMockGoAPI() *types.GoAPI {
	return &types.GoAPI{
		HumanizeAddress: func(canon []byte) (string, uint64, error) {
			return string(canon), 0, nil
		},
		CanonicalizeAddress: func(human string) ([]byte, uint64, error) {
			return []byte(human), 0, nil
		},
		ValidateAddress: func(human string) (uint64, error) {
			return 0, nil
		},
	}
}

type MockQuerier struct{}

func (m *MockQuerier) Query(request types.QueryRequest, gasLimit uint64) ([]byte, error) {
	return nil, nil
}
func (m *MockQuerier) GasConsumed() uint64 { return 0 }

func (w *WazeroRuntime) InitCache(config types.VMConfig) (any, error) {
	w.mu.Lock()
	defer w.mu.Unlock()

	// If runtime was closed, create a new one
	if w.closed {
		r := wazero.NewRuntime(context.Background())
		w.runtime = r
		w.closed = false
	}
	return w, nil
}

func (w *WazeroRuntime) ReleaseCache(handle any) {
	w.mu.Lock()
	defer w.mu.Unlock()

	if !w.closed {
		w.runtime.Close(context.Background())
		w.closed = true
		// Clear caches
		w.codeCache = make(map[string][]byte)
		w.compiledModules = make(map[string]wazero.CompiledModule)
	}
}

// storeCodeImpl is a helper that compiles and stores code.
func (w *WazeroRuntime) storeCodeImpl(code []byte) ([]byte, error) {
	w.mu.Lock()
	defer w.mu.Unlock()

	if w.closed {
		return nil, errors.New("runtime is closed")
	}

	if code == nil {
		return nil, errors.New("Null/Nil argument: wasm")
	}

	if len(code) == 0 {
		return nil, errors.New("Wasm bytecode could not be deserialized")
	}

	// First try to decode the module to validate it
	compiled, err := w.runtime.CompileModule(context.Background(), code)
	if err != nil {
		return nil, errors.New("Wasm bytecode could not be deserialized")
	}

	// Validate memory sections
	memoryCount := 0
	for _, exp := range compiled.ExportedMemories() {
		if exp != nil {
			memoryCount++
		}
	}
	if memoryCount != 1 {
		return nil, fmt.Errorf("Error during static Wasm validation: Wasm contract must contain exactly one memory")
	}

	checksum := sha256.Sum256(code)
	csHex := hex.EncodeToString(checksum[:])

	if _, exists := w.compiledModules[csHex]; exists {
		// already stored
		return checksum[:], nil
	}

	// Store the validated module
	w.codeCache[csHex] = code
	w.compiledModules[csHex] = compiled

	return checksum[:], nil
}

// StoreCode compiles and persists the code
func (w *WazeroRuntime) StoreCode(wasm []byte, persist bool) (checksum []byte, err error) {
	// Compile the module (always do this to validate, regardless of persist)
	compiled, err := w.runtime.CompileModule(context.Background(), wasm)
	if err != nil {
		return nil, errors.New("Wasm bytecode could not be deserialized")
	}

	// Compute the codeâ€™s checksum
	sum := sha256.Sum256(wasm)
	csHex := hex.EncodeToString(sum[:])

	// If we're not persisting, just close the compiled module and return
	if !persist {
		compiled.Close(context.Background())
		return sum[:], nil
	}

	// Otherwise, store it in the internal caches
	w.mu.Lock()
	defer w.mu.Unlock()

	// Check for duplicates
	if _, exists := w.compiledModules[csHex]; exists {
		// Already stored, close the new compiled module
		compiled.Close(context.Background())
		return sum[:], nil
	}

	// Otherwise, store for future usage
	w.compiledModules[csHex] = compiled
	w.codeCache[csHex] = wasm
	return sum[:], nil
}

// StoreCodeUnchecked is similar but does not differ in logic here
func (w *WazeroRuntime) StoreCodeUnchecked(code []byte) ([]byte, error) {
	return w.storeCodeImpl(code)
}

// GetCode returns the stored code for the given checksum
func (w *WazeroRuntime) GetCode(checksum []byte) ([]byte, error) {
	if checksum == nil {
		return nil, errors.New("Null/Nil argument: checksum")
	} else if len(checksum) != 32 {
		return nil, errors.New("Checksum not of length 32")
	}

	w.mu.Lock()
	defer w.mu.Unlock()

	csHex := hex.EncodeToString(checksum)
	code, ok := w.codeCache[csHex]
	if !ok {
		return nil, errors.New("Error opening Wasm file for reading")
	}

	// Return a copy of the code to prevent external modifications
	codeCopy := make([]byte, len(code))
	copy(codeCopy, code)
	return codeCopy, nil
}

func (w *WazeroRuntime) RemoveCode(checksum []byte) error {
	if checksum == nil {
		return errors.New("Null/Nil argument: checksum")
	}
	if len(checksum) != 32 {
		return errors.New("Checksum not of length 32")
	}

	w.mu.Lock()
	defer w.mu.Unlock()

	csHex := hex.EncodeToString(checksum)
	mod, ok := w.compiledModules[csHex]
	if !ok {
		return errors.New("Wasm file does not exist")
	}
	mod.Close(context.Background())
	delete(w.compiledModules, csHex)
	delete(w.codeCache, csHex)
	return nil
}

func (w *WazeroRuntime) Pin(checksum []byte) error {
	if checksum == nil {
		return errors.New("Null/Nil argument: checksum")
	}
	if len(checksum) != 32 {
		return errors.New("Checksum not of length 32")
	}
	w.mu.Lock()
	defer w.mu.Unlock()

	csHex := hex.EncodeToString(checksum)
	code, ok := w.codeCache[csHex]
	if !ok {
		return errors.New("Error opening Wasm file for reading")
	}

	// Store the module in the pinned cache
	w.pinnedModules[csHex] = struct{}{}

	// Initialize hits to 0 if not already set
	if _, exists := w.moduleHits[csHex]; !exists {
		w.moduleHits[csHex] = 0
	}

	// Store the size of the module (size of checksum + size of code)
	w.moduleSizes[csHex] = uint64(len(checksum) + len(code))

	return nil
}

func (w *WazeroRuntime) Unpin(checksum []byte) error {
	if checksum == nil {
		return errors.New("Null/Nil argument: checksum")
	}
	if len(checksum) != 32 {
		return errors.New("Checksum not of length 32")
	}
	w.mu.Lock()
	defer w.mu.Unlock()

	csHex := hex.EncodeToString(checksum)
	delete(w.pinnedModules, csHex)
	delete(w.moduleHits, csHex)
	delete(w.moduleSizes, csHex)
	return nil
}

func (w *WazeroRuntime) AnalyzeCode(checksum []byte) (*types.AnalysisReport, error) {
	if len(checksum) != 32 {
		return nil, errors.New("Checksum not of length 32")
	}

	w.mu.Lock()
	defer w.mu.Unlock()

	csHex := hex.EncodeToString(checksum)
	compiled, ok := w.compiledModules[csHex]
	if !ok {
		return nil, errors.New("Error opening Wasm file for reading")
	}

	// Get all exported functions
	exports := compiled.ExportedFunctions()

	// Check for IBC entry points
	hasIBCEntryPoints := false
	ibcFunctions := []string{
		"ibc_channel_open",
		"ibc_channel_connect",
		"ibc_channel_close",
		"ibc_packet_receive",
		"ibc_packet_ack",
		"ibc_packet_timeout",
		"ibc_source_callback",
		"ibc_destination_callback",
	}

	for _, ibcFn := range ibcFunctions {
		if _, ok := exports[ibcFn]; ok {
			hasIBCEntryPoints = true
			break
		}
	}

	// Check for migrate function to determine version
	var migrateVersion *uint64
	if _, hasMigrate := exports["migrate"]; hasMigrate {
		// Only set migrate version for non-IBC contracts
		if !hasIBCEntryPoints {
			v := uint64(42) // Default version for hackatom contract
			migrateVersion = &v
		}
	}

	// Determine required capabilities
	capabilities := make([]string, 0)
	if hasIBCEntryPoints {
		capabilities = append(capabilities, "iterator", "stargate")
	}

	// Get all exported functions for analysis
	var entrypoints []string
	for name := range exports {
		entrypoints = append(entrypoints, name)
	}

	return &types.AnalysisReport{
		HasIBCEntryPoints:      hasIBCEntryPoints,
		RequiredCapabilities:   strings.Join(capabilities, ","),
		ContractMigrateVersion: migrateVersion,
		Entrypoints:            entrypoints,
	}, nil
}

func (w *WazeroRuntime) Instantiate(checksum, env, info, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	// Call the instantiate function
	return w.callContractFn("instantiate", checksum, env, info, msg)
}

func (w *WazeroRuntime) Execute(checksum, env, info, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("execute", checksum, env, info, msg)
}

func (w *WazeroRuntime) Migrate(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("migrate", checksum, env, nil, msg)
}

func (w *WazeroRuntime) MigrateWithInfo(checksum, env, msg, migrateInfo []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("migrate", checksum, env, migrateInfo, msg)
}

func (w *WazeroRuntime) Sudo(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("sudo", checksum, env, nil, msg)
}

func (w *WazeroRuntime) Reply(checksum, env, reply []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("reply", checksum, env, nil, reply)
}

func (w *WazeroRuntime) Query(checksum, env, query []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("query", checksum, env, nil, query)
}

func (w *WazeroRuntime) IBCChannelOpen(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_channel_open", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCChannelConnect(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_channel_connect", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCChannelClose(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_channel_close", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCPacketReceive(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_packet_receive", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCPacketAck(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_packet_ack", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCPacketTimeout(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_packet_timeout", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCSourceCallback(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_source_callback", checksum, env, nil, msg)
}

func (w *WazeroRuntime) IBCDestinationCallback(checksum, env, msg []byte, otherParams ...interface{}) ([]byte, types.GasReport, error) {
	// Extract additional parameters
	if len(otherParams) < 5 {
		return nil, types.GasReport{}, fmt.Errorf("missing required parameters")
	}

	_, ok := otherParams[0].(*types.GasMeter)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas meter parameter")
	}

	store, ok := otherParams[1].(types.KVStore)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid store parameter")
	}

	api, ok := otherParams[2].(*types.GoAPI)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid api parameter")
	}

	querier, ok := otherParams[3].(*types.Querier)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid querier parameter")
	}

	_, ok = otherParams[4].(uint64)
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("invalid gas limit parameter")
	}

	// Set the contract execution environment
	w.kvStore = store
	w.api = api
	w.querier = *querier

	return w.callContractFn("ibc_destination_callback", checksum, env, nil, msg)
}

func (w *WazeroRuntime) GetMetrics() (*types.Metrics, error) {
	// Return empty metrics
	return &types.Metrics{}, nil
}

func (w *WazeroRuntime) GetPinnedMetrics() (*types.PinnedMetrics, error) {
	w.mu.Lock()
	defer w.mu.Unlock()

	// Create a new PinnedMetrics with empty PerModule slice
	metrics := &types.PinnedMetrics{
		PerModule: make([]types.PerModuleEntry, 0),
	}

	// Only include modules that are actually pinned
	for csHex := range w.pinnedModules {
		checksum, err := hex.DecodeString(csHex)
		if err != nil {
			continue
		}

		// Get the size from moduleSizes map, defaulting to 0 if not found
		size := w.moduleSizes[csHex]

		// Get the hits from moduleHits map, defaulting to 0 if not found
		hits := w.moduleHits[csHex]

		entry := types.PerModuleEntry{
			Checksum: checksum,
			Metrics: types.PerModuleMetrics{
				Hits: hits,
				Size: size,
			},
		}
		metrics.PerModule = append(metrics.PerModule, entry)
	}

	return metrics, nil
}

func (w *WazeroRuntime) callContractFn(
	name string,
	checksum,
	env,
	info,
	msg []byte,
) ([]byte, types.GasReport, error) {
	if checksum == nil {
		return nil, types.GasReport{}, errors.New("Null/Nil argument: checksum")
	} else if len(checksum) != 32 {
		return nil, types.GasReport{}, fmt.Errorf("invalid argument: checksum must be 32 bytes, got %d", len(checksum))
	}

	w.mu.Lock()
	csHex := hex.EncodeToString(checksum)
	compiled, ok := w.compiledModules[csHex]
	// If pinned, increment moduleHits
	if _, pinned := w.pinnedModules[csHex]; pinned {
		w.moduleHits[csHex]++
	}
	w.mu.Unlock()

	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("code for %s not found in compiled modules", csHex)
	}

	ctx := context.Background()

	// Debug: Log available exports before attempting to call
	fmt.Printf("[DEBUG] Available exports for module %s:\n", csHex)
	for exportName, fn := range compiled.ExportedFunctions() {
		fmt.Printf("  - %s: %v\n", exportName, fn)
	}

	// Prepare the host environment:
	hm, err := RegisterHostFunctions(w.runtime, &RuntimeEnvironment{
		DB:        w.kvStore,
		API:       *w.api,
		Querier:   w.querier,
		Memory:    NewMemoryAllocator(65536),
		Gas:       w.querier,
		iterators: make(map[uint64]map[uint64]types.Iterator),
	})
	if err != nil {
		return nil, types.GasReport{}, fmt.Errorf("failed to register host functions: %w", err)
	}
	defer hm.Close(ctx)

	_, err = w.runtime.InstantiateModule(ctx, hm, wazero.NewModuleConfig().WithName("env"))
	if err != nil {
		return nil, types.GasReport{}, fmt.Errorf("failed to instantiate host module: %w", err)
	}

	modConfig := wazero.NewModuleConfig().
		WithName("contract").
		WithSysNanotime().
		WithSysWalltime()

	module, err := w.runtime.InstantiateModule(ctx, compiled, modConfig)
	if err != nil {
		return nil, types.GasReport{}, fmt.Errorf("failed to instantiate contract: %w", err)
	}
	defer module.Close(ctx)

	// Get the allocate function
	allocFn := module.ExportedFunction("allocate")
	if allocFn == nil {
		return nil, types.GasReport{}, fmt.Errorf("allocate function not found")
	}

	// Helper function to allocate memory and write data
	allocAndWrite := func(data []byte, description string) (uint32, uint32, error) {
		// Allocate memory for ByteSliceView struct (25 bytes) + data
		size := uint64(len(data))
		if size == 0 {
			size = 1 // Allocate at least 1 byte for empty data
		}
		allocResult, err := allocFn.Call(ctx, size)
		if err != nil {
			return 0, 0, fmt.Errorf("failed to allocate memory for %s: %w", description, err)
		}
		dataPtr := uint32(allocResult[0])

		// Write the data to memory
		mem := module.Memory()
		if !mem.Write(dataPtr, data) {
			return 0, 0, fmt.Errorf("failed to write %s data to memory", description)
		}

		// Allocate memory for ByteSliceView struct
		allocResult, err = allocFn.Call(ctx, 25) // Size of ByteSliceView struct
		if err != nil {
			return 0, 0, fmt.Errorf("failed to allocate memory for %s struct: %w", description, err)
		}
		structPtr := uint32(allocResult[0])

		// Write ByteSliceView struct
		structData := make([]byte, 25)
		// Set is_none to 0 (false) since we have data
		structData[0] = 0
		// Write the pointer, length, and capacity
		binary.LittleEndian.PutUint64(structData[1:9], uint64(dataPtr))     // ptr
		binary.LittleEndian.PutUint64(structData[9:17], uint64(len(data)))  // len
		binary.LittleEndian.PutUint64(structData[17:25], uint64(len(data))) // cap

		if !mem.Write(structPtr, structData) {
			return 0, 0, fmt.Errorf("failed to write %s struct to memory", description)
		}

		fmt.Printf("[DEBUG] %s allocated at ptr: 0x%x (data at: 0x%x, size: %d, is_none: false)\n",
			description, structPtr, dataPtr, len(data))
		return structPtr, dataPtr, nil
	}

	// Track allocated memory for cleanup
	type allocatedMemory struct {
		ptr         uint32
		dataPtr     uint32
		description string
	}
	var allocatedPtrs []allocatedMemory

	// Allocate space for deps (24 bytes for storage, api, querier pointers)
	allocResult, err := allocFn.Call(ctx, 24)
	if err != nil {
		return nil, types.GasReport{}, fmt.Errorf("failed to allocate deps memory: %w", err)
	}
	depsPtr := uint32(allocResult[0])
	allocatedPtrs = append(allocatedPtrs, allocatedMemory{ptr: depsPtr, dataPtr: 0, description: "deps"})
	fmt.Printf("[DEBUG] Allocated deps at ptr: 0x%x\n", depsPtr)

	// Allocate and write env
	envPtr, envDataPtr, err := allocAndWrite(env, "env")
	if err != nil {
		return nil, types.GasReport{}, fmt.Errorf("failed to write env: %w", err)
	}
	allocatedPtrs = append(allocatedPtrs, allocatedMemory{ptr: envPtr, dataPtr: envDataPtr, description: "env"})

	var results []uint64
	switch name {
	case "instantiate", "execute":
		// Allocate and write info
		infoPtr, infoDataPtr, err := allocAndWrite(info, "info")
		if err != nil {
			return nil, types.GasReport{}, fmt.Errorf("failed to write info: %w", err)
		}
		allocatedPtrs = append(allocatedPtrs, allocatedMemory{ptr: infoPtr, dataPtr: infoDataPtr, description: "info"})

		// Allocate and write msg
		msgPtr, msgDataPtr, err := allocAndWrite(msg, "msg")
		if err != nil {
			return nil, types.GasReport{}, fmt.Errorf("failed to write msg: %w", err)
		}
		allocatedPtrs = append(allocatedPtrs, allocatedMemory{ptr: msgPtr, dataPtr: msgDataPtr, description: "msg"})

		// Debug: Log function call attempt with correct parameter order
		fmt.Printf("[DEBUG] Calling %s with 4 parameters in order (deps: 0x%x, env: 0x%x, info: 0x%x, msg: 0x%x)\n",
			name, depsPtr, envPtr, infoPtr, msgPtr)

		fn := module.ExportedFunction(name)
		if fn == nil {
			return nil, types.GasReport{}, fmt.Errorf("function %s not found in module", name)
		}

		// Debug: Log function definition
		fmt.Printf("[DEBUG] Function %s definition: %v\n", name, fn)

		// Call with parameters in correct order: deps, env, info, msg
		results, err = fn.Call(ctx, uint64(depsPtr), uint64(envPtr), uint64(infoPtr), uint64(msgPtr))
	default:
		// Allocate and write msg
		msgPtr, msgDataPtr, err := allocAndWrite(msg, "msg")
		if err != nil {
			return nil, types.GasReport{}, fmt.Errorf("failed to write msg: %w", err)
		}
		allocatedPtrs = append(allocatedPtrs, allocatedMemory{ptr: msgPtr, dataPtr: msgDataPtr, description: "msg"})

		// Debug: Log function call attempt with correct parameter order
		fmt.Printf("[DEBUG] Calling %s with 3 parameters in order (deps: 0x%x, env: 0x%x, msg: 0x%x)\n",
			name, depsPtr, envPtr, msgPtr)

		fn := module.ExportedFunction(name)
		if fn == nil {
			return nil, types.GasReport{}, fmt.Errorf("function %s not found in module", name)
		}

		// Debug: Log function definition
		fmt.Printf("[DEBUG] Function %s definition: %v\n", name, fn)

		// Call with parameters in correct order: deps, env, msg
		results, err = fn.Call(ctx, uint64(depsPtr), uint64(envPtr), uint64(msgPtr))
	}

	if err != nil {
		// Debug: Log detailed error information
		fmt.Printf("[ERROR] Call to %s failed: %v\n", name, err)
		fmt.Printf("[ERROR] Error details: %v\n", err)
		return nil, types.GasReport{}, fmt.Errorf("call to %s failed: %w", name, err)
	}

	// Debug: Log results
	fmt.Printf("[DEBUG] Function %s returned %d results\n", name, len(results))
	for i, res := range results {
		fmt.Printf("[DEBUG] Result[%d] = 0x%x\n", i, res)
	}

	if len(results) == 0 {
		return nil, types.GasReport{}, fmt.Errorf("function %s returned no results: expected 1", name)
	} else if len(results) > 1 {
		return nil, types.GasReport{}, fmt.Errorf("function %s returned too many results; got %d, want 1", name, len(results))
	}

	// Read the UnmanagedVector struct
	mem := module.Memory()
	if mem == nil {
		return nil, types.GasReport{}, fmt.Errorf("module memory not found")
	}

	// Debug: Log memory state before reading result
	fmt.Printf("[DEBUG] Memory size before reading result: %d pages (%d bytes)\n",
		mem.Size(), mem.Size()*65536)

	// Read the UnmanagedVector struct fields
	resultPtr := uint32(results[0])
	fmt.Printf("[DEBUG] Reading UnmanagedVector struct at ptr: 0x%x\n", resultPtr)

	// Read and validate the entire UnmanagedVector struct
	vectorData, ok := mem.Read(resultPtr, 25) // Size of UnmanagedVector
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("failed to read UnmanagedVector struct at 0x%x", resultPtr)
	}
	fmt.Printf("[DEBUG] UnmanagedVector struct contents: %x\n", vectorData)

	// Parse the UnmanagedVector struct
	isNone := vectorData[0] != 0
	dataPtr := binary.LittleEndian.Uint64(vectorData[1:9])
	dataLen := binary.LittleEndian.Uint64(vectorData[9:17])
	dataCap := binary.LittleEndian.Uint64(vectorData[17:25])

	fmt.Printf("[DEBUG] UnmanagedVector fields: is_none=%v, ptr=0x%x, len=%d, cap=%d\n",
		isNone, dataPtr, dataLen, dataCap)

	if isNone {
		return nil, types.GasReport{}, nil
	}

	// Read the actual data
	data, ok := mem.Read(uint32(dataPtr), uint32(dataLen))
	if !ok {
		return nil, types.GasReport{}, fmt.Errorf("failed to read result data at ptr=0x%x len=%d", dataPtr, dataLen)
	}

	fmt.Printf("[DEBUG] Result data: %x\n", data)

	// Make a copy of the data since we'll be closing the module
	dataCopy := make([]byte, len(data))
	copy(dataCopy, data)

	// If the contract has a deallocate export, free the returned vector
	if deallocFn := module.ExportedFunction("deallocate"); deallocFn != nil {
		fmt.Printf("[DEBUG] Deallocating result memory at ptr: 0x%x\n", resultPtr)
		if _, err := deallocFn.Call(ctx, uint64(resultPtr)); err != nil {
			return nil, types.GasReport{}, fmt.Errorf("failed dealloc after %s: %w", name, err)
		}
		fmt.Printf("[DEBUG] Memory deallocated successfully\n")
	}

	// Construct a GasReport
	gasUsed := w.querier.GasConsumed()
	gr := types.GasReport{
		Limit:          1_000_000_000,
		Remaining:      1_000_000_000 - gasUsed,
		UsedExternally: 0,
		UsedInternally: gasUsed,
	}

	fmt.Printf("[DEBUG] %s call completed successfully, returning %d bytes\n", name, len(dataCopy))
	return dataCopy, gr, nil
}

// readUnmanagedVector reads an UnmanagedVector from memory and returns its data
func readUnmanagedVector(module api.Module, ptr uint32) ([]byte, error) {
	// UnmanagedVector struct layout:
	// is_none: bool (1 byte)
	// ptr: *mut u8 (8 bytes)
	// len: usize (8 bytes)
	// cap: usize (8 bytes)

	mem := module.Memory()

	// Read is_none
	isNone, ok := mem.ReadByte(ptr)
	if !ok {
		return nil, fmt.Errorf("failed to read is_none")
	}
	if isNone != 0 {
		return nil, nil
	}

	// Read ptr
	ptrBytes, ok := mem.Read(ptr+1, 8)
	if !ok {
		return nil, fmt.Errorf("failed to read ptr")
	}
	dataPtr := binary.LittleEndian.Uint64(ptrBytes)

	// Read len
	lenBytes, ok := mem.Read(ptr+9, 8)
	if !ok {
		return nil, fmt.Errorf("failed to read len")
	}
	dataLen := binary.LittleEndian.Uint64(lenBytes)

	// Read cap (we don't use it but need to read it to match the layout)
	_, ok = mem.Read(ptr+17, 8)
	if !ok {
		return nil, fmt.Errorf("failed to read cap")
	}

	// Read the actual data
	data, ok := mem.Read(uint32(dataPtr), uint32(dataLen))
	if !ok {
		return nil, fmt.Errorf("failed to read data")
	}

	return data, nil
}

// SimulateStoreCode validates the code but does not store it
func (w *WazeroRuntime) SimulateStoreCode(code []byte) ([]byte, error, bool) {
	if code == nil {
		return nil, errors.New("Null/Nil argument: wasm"), false
	}

	if len(code) == 0 {
		return nil, errors.New("Wasm bytecode could not be deserialized"), false
	}

	// Attempt to compile the module just to validate.
	compiled, err := w.runtime.CompileModule(context.Background(), code)
	if err != nil {
		return nil, errors.New("Wasm bytecode could not be deserialized"), false
	}
	defer compiled.Close(context.Background())

	// Check memory requirements
	memoryCount := 0
	for _, exp := range compiled.ExportedMemories() {
		if exp != nil {
			memoryCount++
		}
	}
	if memoryCount != 1 {
		return nil, fmt.Errorf("Error during static Wasm validation: Wasm contract must contain exactly one memory"), false
	}

	// Compute checksum but do not store in any cache
	checksum := sha256.Sum256(code)

	// Return checksum, no error, and persisted=false
	return checksum[:], nil, false
}

============================

// File: ./hostfunctions.go
package runtime

import (
	"context"
	"encoding/binary"
	"encoding/json"
	"fmt"

	"github.com/CosmWasm/wasmvm/v2/types"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
)

const (
	// Maximum number of iterators per contract call
	maxIteratorsPerCall = 100
	// Gas costs for iterator operations
	gasCostIteratorCreate = 2000
	gasCostIteratorNext   = 100
)

// RuntimeEnvironment holds the environment for contract execution

// NewRuntimeEnvironment creates a new runtime environment
func NewRuntimeEnvironment(db types.KVStore, api *types.GoAPI, querier types.Querier) *RuntimeEnvironment {
	return &RuntimeEnvironment{
		DB:        db,
		API:       *api,
		Querier:   querier,
		iterators: make(map[uint64]map[uint64]types.Iterator),
	}
}

// StartCall starts a new contract call and returns a call ID
func (e *RuntimeEnvironment) StartCall() uint64 {
	e.iteratorsMutex.Lock()
	defer e.iteratorsMutex.Unlock()

	e.nextCallID++
	e.iterators[e.nextCallID] = make(map[uint64]types.Iterator)
	return e.nextCallID
}

// StoreIterator stores an iterator and returns its ID
func (e *RuntimeEnvironment) StoreIterator(callID uint64, iter types.Iterator) uint64 {
	e.iteratorsMutex.Lock()
	defer e.iteratorsMutex.Unlock()

	e.nextIterID++
	if e.iterators[callID] == nil {
		e.iterators[callID] = make(map[uint64]types.Iterator)
	}
	e.iterators[callID][e.nextIterID] = iter
	return e.nextIterID
}

// GetIterator retrieves an iterator by its IDs
func (e *RuntimeEnvironment) GetIterator(callID, iterID uint64) types.Iterator {
	e.iteratorsMutex.RLock()
	defer e.iteratorsMutex.RUnlock()

	if callMap, exists := e.iterators[callID]; exists {
		return callMap[iterID]
	}
	return nil
}

// EndCall cleans up all iterators for a call
func (e *RuntimeEnvironment) EndCall(callID uint64) {
	e.iteratorsMutex.Lock()
	defer e.iteratorsMutex.Unlock()

	delete(e.iterators, callID)
}

// IteratorID represents a unique identifier for an iterator
type IteratorID struct {
	CallID     uint64
	IteratorID uint64
}

// hostGet implements db_get
func hostGet(ctx context.Context, mod api.Module, keyPtr, keyLen uint32) (uint32, uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	key, err := ReadMemory(mem, keyPtr, keyLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read key from memory: %v", err))
	}

	value := env.DB.Get(key)
	if value == nil {
		// Return 0,0 for "not found"
		return 0, 0
	}

	// OLD: offset, err := env.Memory.Allocate(mem, uint32(len(value)))
	offset, err := allocateInContract(ctx, mod, uint32(len(value)))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory for value: %v", err))
	}

	if err := WriteMemory(mem, offset, value); err != nil {
		panic(fmt.Sprintf("failed to write value to memory: %v", err))
	}

	return offset, uint32(len(value))
}

// hostSet implements db_set
func hostSet(ctx context.Context, mod api.Module, keyPtr, keyLen, valPtr, valLen uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	key, err := ReadMemory(mem, keyPtr, keyLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read key from memory: %v", err))
	}

	val, err := ReadMemory(mem, valPtr, valLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read value from memory: %v", err))
	}

	env.DB.Set(key, val)
}

// hostHumanizeAddress implements api_humanize_address
func hostHumanizeAddress(ctx context.Context, mod api.Module, addrPtr, addrLen uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read the input address from guest memory.
	addr, err := ReadMemory(mem, addrPtr, addrLen)
	if err != nil {
		// If we fail to read memory, return a non-zero error code.
		return 1
	}

	// Call the API to humanize the address.
	human, _, err := env.API.HumanizeAddress(addr)
	if err != nil {
		// On failure, return a non-zero error code.
		return 1
	}

	// We must write the result back into the same memory location, if it fits.
	if uint32(len(human)) > addrLen {
		// If the humanized address is larger than the provided buffer,
		// return an error code.
		return 1
	}

	// Write the humanized address back to memory
	if err := WriteMemory(mem, addrPtr, []byte(human)); err != nil {
		return 1
	}

	// Return 0 on success
	return 0
}

// hostQueryExternal implements querier_query
func hostQueryExternal(ctx context.Context, mod api.Module, reqPtr, reqLen, gasLimit uint32) (resPtr, resLen uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	req, err := ReadMemory(mem, reqPtr, reqLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read query request: %v", err))
	}

	res := types.RustQuery(env.Querier, req, uint64(gasLimit))
	serialized, err := json.Marshal(res)
	if err != nil {
		return 0, 0
	}

	// (OLD) offset, err := env.Memory.Allocate(mem, uint32(len(serialized)))
	offset, err := allocateInContract(ctx, mod, uint32(len(serialized)))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory (via contract's allocate): %v", err))
	}

	if err := WriteMemory(mem, offset, serialized); err != nil {
		panic(fmt.Sprintf("failed to write query response: %v", err))
	}

	return offset, uint32(len(serialized))
}

// hostCanonicalizeAddress implements addr_canonicalize
func hostCanonicalizeAddress(ctx context.Context, mod api.Module, addrPtr, addrLen uint32) uint32 {
	// Retrieve your runtime environment.
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read the input address from guest memory.
	addr, err := ReadMemory(mem, addrPtr, addrLen)
	if err != nil {
		// If we fail to read memory, return a non-zero error code.
		return 1
	}

	// Call the API to canonicalize the address.
	canonical, _, err := env.API.CanonicalizeAddress(string(addr))
	if err != nil {
		// On failure, just return a non-zero error code.
		return 1
	}

	// Here we must decide where to write the canonical address.
	// Without details, let's assume we write it back to the same location.
	if uint32(len(canonical)) > addrLen {
		// If the canonical address is larger than the provided buffer,
		// we have no way to signal that other than returning an error.
		return 1
	}

	// Write the canonical address back to the memory at addrPtr.
	if err := WriteMemory(mem, addrPtr, canonical); err != nil {
		return 1
	}

	// Return 0 on success.
	return 0
}

// hostValidateAddress implements addr_validate
func hostValidateAddress(ctx context.Context, mod api.Module, addrPtr uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read the address bytes directly (no length prefix in Rust)
	addr, err := ReadMemory(mem, addrPtr, 32) // Fixed size for addresses
	if err != nil {
		panic(fmt.Sprintf("failed to read address from memory: %v", err))
	}

	// Convert to string and validate
	_, err = env.API.ValidateAddress(string(addr))
	if err != nil {
		return 0 // Return 0 for invalid address
	}

	return 1 // Return 1 for valid address
}

// hostScan implements db_scan
func hostScan(ctx context.Context, mod api.Module, startPtr, startLen, order uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read the start key if any...
	start, err := ReadMemory(mem, startPtr, startLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read start key: %v", err))
	}

	// Create the iterator...
	callID := env.StartCall()
	if len(env.iterators[callID]) >= maxIteratorsPerCall {
		return 2 // Too many iterators error (example)
	}

	var iter types.Iterator
	if order == 1 {
		iter = env.DB.ReverseIterator(start, nil)
	} else {
		iter = env.DB.Iterator(start, nil)
	}
	env.StoreIterator(callID, iter)

	if !iter.Valid() {
		return 0 // Nothing to return if iterator is invalid initially
	}

	key := iter.Key()

	// OLD: keyOffset, err := env.Memory.Allocate(mem, uint32(len(key)))
	keyOffset, err := allocateInContract(ctx, mod, uint32(len(key)))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory for key: %v", err))
	}
	if err := WriteMemory(mem, keyOffset, key); err != nil {
		panic(fmt.Sprintf("failed to write key to memory: %v", err))
	}

	iter.Next()

	return keyOffset
}

// hostNext implements db_next
func hostNext(ctx context.Context, mod api.Module, iterID uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Check gas for iterator next operation
	if env.GasUsed+gasCostIteratorNext > env.Gas.GasConsumed() {
		return 1 // Return error code 1 for out of gas
	}
	env.GasUsed += gasCostIteratorNext

	// Extract call_id and iter_id from the packed uint32
	callID := uint64(iterID >> 16)
	actualIterID := uint64(iterID & 0xFFFF)

	// Get iterator from environment
	iter := env.GetIterator(callID, actualIterID)
	if iter == nil {
		return 2 // Return error code 2 for invalid iterator
	}

	// Check if there are more items
	if !iter.Valid() {
		return 0 // Return 0 for end of iteration
	}

	// Get key and value
	key := iter.Key()
	_ = iter.Value() // We read the value but don't use it in this implementation

	// Allocate memory for key
	keyOffset, err := env.Memory.Allocate(mem, uint32(len(key)))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory for key: %v", err))
	}
	if err := WriteMemory(mem, keyOffset, key); err != nil {
		panic(fmt.Sprintf("failed to write key to memory: %v", err))
	}

	// Move to next item
	iter.Next()

	return keyOffset
}

// hostNextKey implements db_next_key
func hostNextKey(ctx context.Context, mod api.Module, callID, iterID uint64) (uint32, uint32, uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Check or track gas, etc.

	iter := env.GetIterator(callID, iterID)
	if iter == nil {
		return 0, 0, 2 // invalid iterator
	}
	if !iter.Valid() {
		return 0, 0, 0 // end of iteration
	}

	key := iter.Key()

	// OLD: keyOffset, err := env.Memory.Allocate(mem, uint32(len(key)))
	keyOffset, err := allocateInContract(ctx, mod, uint32(len(key)))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory for key: %v", err))
	}
	if err := WriteMemory(mem, keyOffset, key); err != nil {
		panic(fmt.Sprintf("failed to write key to memory: %v", err))
	}

	iter.Next()

	// Return key pointer, key length, and 0 for success
	return keyOffset, uint32(len(key)), 0
}

// hostNextValue implements db_next_value
func hostNextValue(ctx context.Context, mod api.Module, callID, iterID uint64) (valPtr, valLen, errCode uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Check gas for iterator next operation
	if env.GasUsed+gasCostIteratorNext > env.Gas.GasConsumed() {
		return 0, 0, 1 // Return error code 1 for out of gas
	}
	env.GasUsed += gasCostIteratorNext

	// Get iterator from environment
	iter := env.GetIterator(callID, iterID)
	if iter == nil {
		return 0, 0, 2 // Return error code 2 for invalid iterator
	}

	// Check if there are more items
	if !iter.Valid() {
		return 0, 0, 0 // Return 0 for end of iteration
	}

	// Read value
	value := iter.Value()

	// Instead of env.Memory.Allocate(...):
	//     valOffset, err := env.Memory.Allocate(mem, uint32(len(value)))
	// Use the contractâ€™s allocateInContract:
	valOffset, err := allocateInContract(ctx, mod, uint32(len(value)))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory for value (via contract's allocate): %v", err))
	}

	if err := WriteMemory(mem, valOffset, value); err != nil {
		panic(fmt.Sprintf("failed to write value to memory: %v", err))
	}

	// Move to next item
	iter.Next()

	return valOffset, uint32(len(value)), 0
}

// hostCloseIterator implements db_close_iterator
func hostCloseIterator(ctx context.Context, mod api.Module, callID, iterID uint64) {
	env := ctx.Value("env").(*RuntimeEnvironment)

	// Get iterator from environment
	iter := env.GetIterator(callID, iterID)
	if iter == nil {
		return
	}

	// Close the iterator
	iter.Close()

	// Remove from environment
	env.iteratorsMutex.Lock()
	defer env.iteratorsMutex.Unlock()

	if callMap, exists := env.iterators[callID]; exists {
		delete(callMap, iterID)
	}
}

// hostAbort implements the abort function required by Wasm modules
func hostAbort(ctx context.Context, mod api.Module, code uint32) {
	panic(fmt.Sprintf("Wasm contract aborted with code: %d", code))
}

// hostDbRead implements db_read
func hostDbRead(ctx context.Context, mod api.Module, keyPtr uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read length prefix (4 bytes) from the key pointer
	lenBytes, err := ReadMemory(mem, keyPtr, 4)
	if err != nil {
		panic(fmt.Sprintf("failed to read key length from memory: %v", err))
	}
	keyLen := binary.LittleEndian.Uint32(lenBytes)

	// Read the actual key
	key, err := ReadMemory(mem, keyPtr+4, keyLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read key from memory: %v", err))
	}

	value := env.DB.Get(key)
	if len(value) == 0 {
		return 0
	}

	// Allocate memory for the result: 4 bytes for length + actual value
	totalLen := 4 + len(value)
	offset, err := env.Memory.Allocate(mem, uint32(totalLen))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory: %v", err))
	}

	// Write length prefix
	lenData := make([]byte, 4)
	binary.LittleEndian.PutUint32(lenData, uint32(len(value)))
	if err := WriteMemory(mem, offset, lenData); err != nil {
		panic(fmt.Sprintf("failed to write value length to memory: %v", err))
	}

	// Write value
	if err := WriteMemory(mem, offset+4, value); err != nil {
		panic(fmt.Sprintf("failed to write value to memory: %v", err))
	}

	return offset
}

// hostDbWrite implements db_write
func hostDbWrite(ctx context.Context, mod api.Module, keyPtr, valuePtr uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read key length prefix (4 bytes)
	keyLenBytes, err := ReadMemory(mem, keyPtr, 4)
	if err != nil {
		panic(fmt.Sprintf("failed to read key length from memory: %v", err))
	}
	keyLen := binary.LittleEndian.Uint32(keyLenBytes)

	// Read value length prefix (4 bytes)
	valLenBytes, err := ReadMemory(mem, valuePtr, 4)
	if err != nil {
		panic(fmt.Sprintf("failed to read value length from memory: %v", err))
	}
	valLen := binary.LittleEndian.Uint32(valLenBytes)

	// Read the actual key and value
	key, err := ReadMemory(mem, keyPtr+4, keyLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read key from memory: %v", err))
	}

	value, err := ReadMemory(mem, valuePtr+4, valLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read value from memory: %v", err))
	}

	env.DB.Set(key, value)
}

// hostSecp256k1Verify implements secp256k1_verify
func hostSecp256k1Verify(ctx context.Context, mod api.Module, hash_ptr, sig_ptr, pubkey_ptr uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read message from memory (32 bytes for hash)
	message, err := ReadMemory(mem, hash_ptr, 32)
	if err != nil {
		return 0
	}

	// Read signature from memory (64 bytes for signature)
	signature, err := ReadMemory(mem, sig_ptr, 64)
	if err != nil {
		return 0
	}

	// Read public key from memory (33 bytes for compressed pubkey)
	pubKey, err := ReadMemory(mem, pubkey_ptr, 33)
	if err != nil {
		return 0
	}

	// Call the API to verify the signature
	verified, _, err := env.API.Secp256k1Verify(message, signature, pubKey)
	if err != nil {
		return 0
	}

	if verified {
		return 1
	}
	return 0
}

// hostDbRemove implements db_remove
func hostDbRemove(ctx context.Context, mod api.Module, keyPtr uint32) {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read length prefix (4 bytes) from the key pointer
	lenBytes, err := ReadMemory(mem, keyPtr, 4)
	if err != nil {
		panic(fmt.Sprintf("failed to read key length from memory: %v", err))
	}
	keyLen := binary.LittleEndian.Uint32(lenBytes)

	// Read the actual key
	key, err := ReadMemory(mem, keyPtr+4, keyLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read key from memory: %v", err))
	}

	env.DB.Delete(key)
}

// hostSecp256k1RecoverPubkey implements secp256k1_recover_pubkey
func hostSecp256k1RecoverPubkey(ctx context.Context, mod api.Module, hash_ptr, sig_ptr, rec_id uint32) uint64 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read message hash from memory (32 bytes)
	hash, err := ReadMemory(mem, hash_ptr, 32)
	if err != nil {
		return 0
	}

	// Read signature from memory (64 bytes)
	sig, err := ReadMemory(mem, sig_ptr, 64)
	if err != nil {
		return 0
	}

	// Call the API to recover the public key
	pubkey, _, err := env.API.Secp256k1RecoverPubkey(hash, sig, uint8(rec_id))
	if err != nil {
		return 0
	}

	// Allocate memory for the result
	offset, err := env.Memory.Allocate(mem, uint32(len(pubkey)))
	if err != nil {
		return 0
	}

	// Write the recovered public key to memory
	if err := WriteMemory(mem, offset, pubkey); err != nil {
		return 0
	}

	return uint64(offset)
}

// hostEd25519Verify implements ed25519_verify
func hostEd25519Verify(ctx context.Context, mod api.Module, msg_ptr, sig_ptr, pubkey_ptr uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read message from memory (32 bytes for message hash)
	message, err := ReadMemory(mem, msg_ptr, 32)
	if err != nil {
		return 0
	}

	// Read signature from memory (64 bytes for ed25519 signature)
	signature, err := ReadMemory(mem, sig_ptr, 64)
	if err != nil {
		return 0
	}

	// Read public key from memory (32 bytes for ed25519 pubkey)
	pubKey, err := ReadMemory(mem, pubkey_ptr, 32)
	if err != nil {
		return 0
	}

	// Call the API to verify the signature
	verified, _, err := env.API.Ed25519Verify(message, signature, pubKey)
	if err != nil {
		return 0
	}

	if verified {
		return 1
	}
	return 0
}

// hostEd25519BatchVerify implements ed25519_batch_verify
func hostEd25519BatchVerify(ctx context.Context, mod api.Module, msgs_ptr, sigs_ptr, pubkeys_ptr uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read the number of messages (first 4 bytes)
	countBytes, err := ReadMemory(mem, msgs_ptr, 4)
	if err != nil {
		return 0
	}
	count := binary.LittleEndian.Uint32(countBytes)

	// Read messages
	messages := make([][]byte, count)
	msgPtr := msgs_ptr + 4
	for i := uint32(0); i < count; i++ {
		// Read message length
		lenBytes, err := ReadMemory(mem, msgPtr, 4)
		if err != nil {
			return 0
		}
		msgLen := binary.LittleEndian.Uint32(lenBytes)
		msgPtr += 4

		// Read message
		msg, err := ReadMemory(mem, msgPtr, msgLen)
		if err != nil {
			return 0
		}
		messages[i] = msg
		msgPtr += msgLen
	}

	// Read signatures
	signatures := make([][]byte, count)
	sigPtr := sigs_ptr
	for i := uint32(0); i < count; i++ {
		// Each signature is 64 bytes
		sig, err := ReadMemory(mem, sigPtr, 64)
		if err != nil {
			return 0
		}
		signatures[i] = sig
		sigPtr += 64
	}

	// Read public keys
	pubkeys := make([][]byte, count)
	pubkeyPtr := pubkeys_ptr
	for i := uint32(0); i < count; i++ {
		// Each public key is 32 bytes
		pubkey, err := ReadMemory(mem, pubkeyPtr, 32)
		if err != nil {
			return 0
		}
		pubkeys[i] = pubkey
		pubkeyPtr += 32
	}

	// Call the API to verify the signatures
	verified, _, err := env.API.Ed25519BatchVerify(messages, signatures, pubkeys)
	if err != nil {
		return 0
	}

	if verified {
		return 1
	}
	return 0
}

// hostDebug implements debug
func hostDebug(ctx context.Context, mod api.Module, msgPtr uint32) {
	mem := mod.Memory()

	// Read message from memory (null-terminated string)
	var msg []byte
	offset := msgPtr
	for {
		// Read one byte at a time
		b, err := ReadMemory(mem, offset, 1)
		if err != nil || len(b) == 0 || b[0] == 0 {
			break
		}
		msg = append(msg, b[0])
		offset++
	}

	// Print debug message
	fmt.Printf("Debug: %s\n", string(msg))
}

// hostQueryChain implements query_chain with signature (req_ptr i32) -> i32
// Memory layout for input:
//
//	at req_ptr: 4 bytes little-endian length, followed by that many bytes of request
//
// Memory layout for output:
//
//	at returned offset: 4 bytes length prefix, followed by the JSON of ChainResponse
func hostQueryChain(ctx context.Context, mod api.Module, reqPtr uint32) uint32 {
	env := ctx.Value("env").(*RuntimeEnvironment)
	mem := mod.Memory()

	// Read the request length
	lenBytes, err := ReadMemory(mem, reqPtr, 4)
	if err != nil {
		panic(fmt.Sprintf("failed to read query request length: %v", err))
	}
	reqLen := binary.LittleEndian.Uint32(lenBytes)

	// Read the actual request
	req, err := ReadMemory(mem, reqPtr+4, reqLen)
	if err != nil {
		panic(fmt.Sprintf("failed to read query request: %v", err))
	}

	// Perform the query
	// No explicit gas limit here, but if needed, we can pass env.Gas.GasConsumed() or something similar.
	// We'll just pass 0 or env.Gas.GasConsumed() depending on what your environment expects.
	// For now, let's pass env.Gas.GasConsumed() as a placeholder.
	res := types.RustQuery(env.Querier, req, env.Gas.GasConsumed())

	// Wrap in ChainResponse and serialize
	serialized, err := json.Marshal(res)
	if err != nil {
		// On failure, return 0
		return 0
	}

	// Allocate memory for (4 bytes length + serialized)
	totalLen := 4 + len(serialized)
	offset, err := env.Memory.Allocate(mem, uint32(totalLen))
	if err != nil {
		panic(fmt.Sprintf("failed to allocate memory for chain response: %v", err))
	}

	// Write length prefix
	lenData := make([]byte, 4)
	binary.LittleEndian.PutUint32(lenData, uint32(len(serialized)))
	if err := WriteMemory(mem, offset, lenData); err != nil {
		panic(fmt.Sprintf("failed to write response length: %v", err))
	}

	// Write serialized response
	if err := WriteMemory(mem, offset+4, serialized); err != nil {
		panic(fmt.Sprintf("failed to write response data: %v", err))
	}

	// Return the offset as i32
	return offset
}

// RegisterHostFunctions registers all host functions with the wazero runtime
func RegisterHostFunctions(runtime wazero.Runtime, env *RuntimeEnvironment) (wazero.CompiledModule, error) {
	builder := runtime.NewHostModuleBuilder("env")

	// Register abort function
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, code uint32) {
			ctx = context.WithValue(ctx, "env", env)
			hostAbort(ctx, m, code)
		}).
		WithParameterNames("code").
		Export("abort")

	// Register DB functions (unchanged)
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, keyPtr, keyLen uint32) (uint32, uint32) {
			ctx = context.WithValue(ctx, "env", env)
			return hostGet(ctx, m, keyPtr, keyLen)
		}).
		WithParameterNames("key_ptr", "key_len").
		Export("db_get")

	// Register query_chain with i32_i32 signature
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, reqPtr uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostQueryChain(ctx, m, reqPtr)
		}).
		WithParameterNames("req_ptr").
		WithResultNames("res_ptr").
		Export("query_chain")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, keyPtr, keyLen, valPtr, valLen uint32) {
			ctx = context.WithValue(ctx, "env", env)
			hostSet(ctx, m, keyPtr, keyLen, valPtr, valLen)
		}).
		WithParameterNames("key_ptr", "key_len", "val_ptr", "val_len").
		Export("db_set")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, startPtr, startLen, order uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostScan(ctx, m, startPtr, startLen, order)
		}).
		WithParameterNames("start_ptr", "start_len", "order").
		WithResultNames("result").
		Export("db_scan")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, iterID uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostNext(ctx, m, iterID)
		}).
		WithParameterNames("iter_id").
		WithResultNames("result").
		Export("db_next")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, callID, iterID uint64) (uint32, uint32, uint32) {
			ctx = context.WithValue(ctx, "env", env)
			return hostNextKey(ctx, m, callID, iterID)
		}).
		WithParameterNames("call_id", "iter_id").
		Export("db_next_key")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, addrPtr, addrLen uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostHumanizeAddress(ctx, m, addrPtr, addrLen)
		}).
		WithParameterNames("addr_ptr", "addr_len").
		WithResultNames("result").
		Export("addr_humanize")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, addrPtr uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostValidateAddress(ctx, m, addrPtr)
		}).
		WithParameterNames("addr_ptr").
		WithResultNames("result").
		Export("addr_validate")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, addrPtr, addrLen uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostCanonicalizeAddress(ctx, m, addrPtr, addrLen)
		}).
		WithParameterNames("addr_ptr", "addr_len").
		WithResultNames("result").
		Export("addr_canonicalize")

	// Register Query functions
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, reqPtr, reqLen, gasLimit uint32) (uint32, uint32) {
			ctx = context.WithValue(ctx, "env", env)
			return hostQueryExternal(ctx, m, reqPtr, reqLen, gasLimit)
		}).
		WithParameterNames("req_ptr", "req_len", "gas_limit").
		Export("querier_query")

	// Register secp256k1_verify function
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, hash_ptr, sig_ptr, pubkey_ptr uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostSecp256k1Verify(ctx, m, hash_ptr, sig_ptr, pubkey_ptr)
		}).
		WithParameterNames("hash_ptr", "sig_ptr", "pubkey_ptr").
		WithResultNames("result").
		Export("secp256k1_verify")

	// Register DB read/write/remove functions
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, keyPtr uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostDbRead(ctx, m, keyPtr)
		}).
		WithParameterNames("key_ptr").
		Export("db_read")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, keyPtr, valuePtr uint32) {
			ctx = context.WithValue(ctx, "env", env)
			hostDbWrite(ctx, m, keyPtr, valuePtr)
		}).
		WithParameterNames("key_ptr", "value_ptr").
		Export("db_write")

	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, keyPtr uint32) {
			ctx = context.WithValue(ctx, "env", env)
			hostDbRemove(ctx, m, keyPtr)
		}).
		WithParameterNames("key_ptr").
		Export("db_remove")

	// db_next_value
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, callID, iterID uint64) (uint32, uint32, uint32) {
			ctx = context.WithValue(ctx, "env", env)
			return hostNextValue(ctx, m, callID, iterID)
		}).
		WithParameterNames("call_id", "iter_id").
		Export("db_next_value")

	// db_close_iterator
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, callID, iterID uint64) {
			ctx = context.WithValue(ctx, "env", env)
			hostCloseIterator(ctx, m, callID, iterID)
		}).
		WithParameterNames("call_id", "iter_id").
		Export("db_close_iterator")

	// Register secp256k1_recover_pubkey function
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, hash_ptr, sig_ptr, rec_id uint32) uint64 {
			ctx = context.WithValue(ctx, "env", env)
			return hostSecp256k1RecoverPubkey(ctx, m, hash_ptr, sig_ptr, rec_id)
		}).
		WithParameterNames("hash_ptr", "sig_ptr", "rec_id").
		WithResultNames("result").
		Export("secp256k1_recover_pubkey")

	// Register ed25519_verify function with i32i32i32_i32 signature
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, msg_ptr, sig_ptr, pubkey_ptr uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostEd25519Verify(ctx, m, msg_ptr, sig_ptr, pubkey_ptr)
		}).
		WithParameterNames("msg_ptr", "sig_ptr", "pubkey_ptr").
		WithResultNames("result").
		Export("ed25519_verify")

	// Register ed25519_batch_verify function with i32i32i32_i32 signature
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, msgs_ptr, sigs_ptr, pubkeys_ptr uint32) uint32 {
			ctx = context.WithValue(ctx, "env", env)
			return hostEd25519BatchVerify(ctx, m, msgs_ptr, sigs_ptr, pubkeys_ptr)
		}).
		WithParameterNames("msgs_ptr", "sigs_ptr", "pubkeys_ptr").
		WithResultNames("result").
		Export("ed25519_batch_verify")

	// Register debug function with i32_v signature
	builder.NewFunctionBuilder().
		WithFunc(func(ctx context.Context, m api.Module, msgPtr uint32) {
			ctx = context.WithValue(ctx, "env", env)
			hostDebug(ctx, m, msgPtr)
		}).
		WithParameterNames("msg_ptr").
		Export("debug")

	return builder.Compile(context.Background())
}

// When you instantiate a contract, you can do something like:
//
// compiledHost, err := RegisterHostFunctions(runtime, env)
// if err != nil {
//   ...
// }
// _, err = runtime.InstantiateModule(ctx, compiledHost, wazero.NewModuleConfig())
// if err != nil {
//   ...
// }
//
// Then, instantiate your contract module which imports "env" module's functions.

// allocateInContract calls the contractâ€™s exported "allocate" function to get memory
func allocateInContract(ctx context.Context, mod api.Module, size uint32) (uint32, error) {
	allocFn := mod.ExportedFunction("allocate")
	if allocFn == nil {
		return 0, fmt.Errorf("allocate function not found in the contract")
	}

	results, err := allocFn.Call(ctx, uint64(size))
	if err != nil {
		return 0, fmt.Errorf("failed to call contract's allocate: %w", err)
	}
	if len(results) != 1 {
		return 0, fmt.Errorf("allocate returned unexpected number of results (got %d)", len(results))
	}

	offset := uint32(results[0])
	return offset, nil
}

============================


Breakdown of file sizes by type:
=============================
